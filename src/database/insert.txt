INSERT INTO `produtos` VALUES 
(1,'A','CABO CAFET ITALIANA 03 CAFES G.R M 2',3,5),
(2,'A','BORR PAN PRESS SILIC ERILAR 13-18-22l FINA GUAM',15,30),
(3,'A','REGULADOR GD 2000 - 02KG/H IMAR',5,10),
(4,'A','BORR PAN PRESS SILIC MULTIUSO 7L AZ CWA',5,10),
(5,'A','BORR PAN PRESS SILIC ETERNA NIGRO 3-4,5-6L S/PQ CWA',5,10),
(6,'A','BORR PAN PRESS COMUM FULGOR 12-20L GUAM',5,10),
(7,'A','CABO PANELA TIPO TRAMONTINA C028 LL',5,25),
(8,'A','CABO PANELA 03F PQ C063 LL M3',5,10),
(9,'A','BORR PAN PRESS SILIC 3D ALCAST 4,5L S/PIQ CWA',5,10),
(10,'A','CABO CAFET ITALIANA 06 CAFES G.R M 2',5,25),
(11,'A','CABO CAFET ITALIANA 09 CAFES G.R M 2',5,25),
(12,'A','BORR PAN PRESS SILIC ETERNA NIGRO 4,5L GUAM',5,10),
(13,'A','BORR PAN PRESS COMUM FULGOR 12-15-20L GUAM',5,10),
(14,'A','CABO PANELA SUPERIOR TAMPA VALENCIA TRAM',3,5),
(15,'A','BORR PAN PRESS SILIC PANEX LIDER 3-4-5-7L GUAM',5,10),
(16,'A','MANGUEIRA GLP 18*10MM 1250MM RENATA',5,10),
(17,'A','BORR PAN PRESS SILIC ROCHEDO 11,4-20,8L GUAM',5,10),
(18,'A','GUARNICAO CAFET ITALIANA 03 CAFES GUAM PT 2',3,5),
(19,'A','GUARNICAO CAFET ITALIANA 06 CAFES GUAM PT 2',3,5),
(20,'A','GUARNICAO CAFET ITALIANA 09 CAFES GUAM PT 2',3,5),
(21,'A','ABRACADEIRA PRESS 5/8 * 3/4 M 10',10,25),
(22,'A','REBITE PANELA 5/32 * 8 PT 100GR',10,25),
(23,'A','REBITE PANELA 5/32 * 22 PT 100GR',10,25),
(24,'A','REBITE PANELA 3/16 * 11 PT 100GR',10,25),
(25,'A','REBITE PANELA 5/32 * 10 PT 100GR',10,25),
(26,'A','REGULADOR GD 506/01 ALIANCA',3,5),
(27,'A','REGULADOR PQ IMAR',3,5),
(28,'A','REGULADOR PQ NV 504/1 ALIANCA',3,5),
(29,'A','ALCA CAÇAROLA PANELA PRESS A025 LL M3',5,35),
(30,'A','CABO PAN PRESS CLOCK MOD 3F C006 LL M2',5,15),
(31,'A','CABO LEITEIRA LARGO LUXO GD LL M3',5,15),
(32,'A','PESO PAN PRESS CROM PENEDO M10',5,15),
(33,'A','ALCA PAN PRESS GLOBO MOD A019 LL M3',5,15),
(34,'A','CABO PAN PRESS PENEDO ROCHEDO CORPO C ACESS LL',5,15),
(35,'A','CABO FRIGIDEIRA MD 03F C056 LL M3',5,15),
(36,'A','CABO CACAROLA LUXO C060 LL',5,15),
(37,'A','CABO FRIGIDEIRA LUXO C060F LL',5,15),
(38,'A','CABO FRIGIDEIRA PQ 03F C065 LL M3',5,15),
(39,'A','PESO PAN PRESS CROM ETERNA NIGRO M10',5,15),
(40,'A','PESO PAN PRESS CAPA AZ UNIV M10 ALTIMAR',5,15),
(41,'A','PESO PAN PRESS CROM CLOCK M10 ALTIMAR',5,15),
(42,'A','PESO PAN PRESS CAPA CLOCK PR M10',5,15),
(43,'A','PESO PAN PRESS CAPA CLOCK VERM M10',5,15),
(44,'A','PESO PAN PRESS CAPA PANEX PR M10',5,15),
(45,'A','BORR PAN PRESS SILIC TP ORIGINAL CLOCK 4.5L CWA',5,100),
(46,'A','CABO LEITEIRA LARGO LUXO GD M3',5,15),
(47,'A','CABO LEITEIRA MARMICOC LARGO MINI M3',5,15),
(48,'A','CABO PAN PRESS PENEDO ROCHEDO CORPO LEVE S SUP M3',5,15),
(49,'A','PESO PAN PRESS CAPA AZ UNIV MINI M10',5,15),
(50,'A','PESO PAN PRESS CAPA CLOCK NV PR AM M10',5,15)
(51,'A','PESO PAN PRESS CAPA CLOCK NV PR AZ M10',5,15),
(52,'A','CABO LEITEIRA 4F PQ 2046 MCA M3',5,15),
(53,'A','SELO REPET PAN PRESS SILIC ROCHEDO NIGRO CWA M10',5,15),
(54,'A','ALCA PAN PRESS GLOBO MOD A007 M3 GR',5,15),
(55,'A','ALCA PAN PRESS ROCHEDO CANNERS CORPO TP ORIG M3',5,15),
(56,'A','CAPA PINO INDICAD SILIC PAN PRESS TRAMONTINA PT2',5,15),
(57,'A','CABO CACAROLA LUXO MD 20 MCA M3',5,15),
(58,'A','KIT REPARO P PAN PRESS VANCOUVER 1 PESO 1PINO TRAM',5,15),
(59,'A','SELO REPET PAN PRESS VANCOUVER TRAMONTINA M4',5,15),
(60,'A','SELO PAN PRESS VANCOUVER P CABO TAMPA TRAM M2',5,15),
(61,'A','CABO CACAROLA LUXO GD 21 MCA M3',5,15),
(62,'A','CABO PAN PRESS SUPERIOR TAMPA VALENCIA TRAM',5,15),
(63,'A','BORR PAN PRESS SILIC MULTIUSO 4.5L TURBO TOP C EMB',5,15),
(64,'A','CABO CACAROLA MAD GD 402 MCA M3',5,15),
(65,'A','SELO PANELA PRESS CLOCK M10',5,100),
(66,'A','CABO CACAROLA MAD MD 401 MCA M3',5,15),
(67,'A','SELO PAN PRESS ROCHEDO NIGRO GUAM M20',5,100),
(68,'A','SELO REPET PAN PRESS SILIC ROCHEDO NIGRO GUAM M10',5,100),
(69,'A','CABO LEITEIRA LUXO 07 MCA M3',5,15),
(70,'A','CABO CANECA PQ 35 MCA M3',5,15),
(71,'A','CABO CANECA MD 36 MCA M3',5,15),
(72,'A','CABO CANECA GD 37 MCA M3',5,15),
(73,'A','CABO CACAROLA CM PQ 10 MCA M3',5,15),
(74,'A','HASTE PAN PRESS CLOCK ANT 4.5L',5,15),
(75,'A','HASTE PAN PRESS CLOCK MOD 4.5L',5,15),
(76,'A','HASTE PAN PRESS CLOCK ANT 7L',5,15),
(77,'A','HASTE PAN PRESS CLOCK MOD 7L',5,15),
(78,'A','HASTE PAN PRESS PANEX LIDER ANT 4.5L',5,15),
(79,'A','PESO PAN PRESS CAPA PR UNIV MINI M10',5,15),
(80,'A','PESO PAN PRESS CAPA CLOCK NV PR VERM M10',5,15),
(81,'A','PESO PANELA PRESS CAPA VERM UNIV MINI M10',5,15),
(82,'A','CABO MADEIRA TACHO PASTELEIRO',8,20);

INSERT INTO `entrada_produtos` VALUES 
(1,1,12,1.47,'2021-07-02'),
(2,2,3,24.93,'2021-07-02'),
(3,3,5,33.66,'2021-07-02'),
(4,4,30,1.37,'2021-07-02'),
(5,5,12,12.23,'2021-07-02'),
(6,6,12,17.24,'2021-07-02'),
(7,7,9,3.17,'2021-07-02'),
(8,8,12,2.23,'2021-07-02'),
(9,9,3,12.40,'2021-07-02'),
(10,10,10,16.30,'2021-07-02'),
(11,11,4,7.17,'2021-07-02'),
(12,12,6,16.71,'2021-07-02'),
(13,13,5,27.57,'2021-07-02'),
(14,14,2,56.21,'2021-07-02'),
(15,15,30,1.94,'2021-07-02'),
(16,16,20,8.14,'2021-07-02'),
(17,17,5,24.93,'2021-07-02'),
(18,18,3,5.00,'2021-07-02'),
(19,19,2,6.67,'2021-07-02'),
(20,20,5,3.84,'2021-07-02'),
(21,21,50,1.35,'2021-07-02'),
(22,22,2,7.87,'2021-07-02'),
(23,23,2,8.22,'2021-07-02'),
(24,24,2,8.00,'2021-07-02'),
(25,25,2,8.00,'2021-07-02'),
(26,26,5,36.07,'2021-07-02'),
(27,27,5,17.28,'2021-07-02'),
(28,28,5,27.28,'2021-07-02'),
(29,29,21,33.19,'2021-07-02'),
(30,30,10,9.35,'2021-07-02'),
(31,31,21,2.00,'2021-07-02'),
(32,32,20,2.90,'2021-07-02'),
(33,33,21,1.60,'2021-07-02'),
(34,34,12,4.53,'2021-07-02'),
(35,35,21,2.25,'2021-07-02'),
(36,36,20,3.00,'2021-07-02'),
(37,37,20,3.35,'2021-07-02'),
(38,38,21,2.00,'2021-07-02'),
(39,39,10,5.00,'2021-07-02'),
(40,40,20,2.62,'2021-07-02'),
(41,41,20,2.81,'2021-07-02'),
(42,42,20,2.48,'2021-07-02'),
(43,20,20,2.50,'2021-07-02'),
(44,44,20,2.50,'2021-07-02'),
(45,45,100,1.29,'2021-07-02'),
(46,46,21,1.90,'2021-07-02'),
(47,47,12,1.20,'2021-07-02'),
(48,48,12,1.90,'2021-07-02'),
(49,49,20,2.05,'2021-07-02'),
(50,50,20,3.00,'2021-07-02'),
(51,51,20,3.00,'2021-07-02'),
(52,52,15,2.61,'2021-07-02'),
(53,53,50,0.72,'2021-07-02'),
(54,54,30,1.21,'2021-07-02'),
(55,55,6,2.38,'2021-07-02'),
(56,56,3,7.00,'2021-07-02'),
(57,57,21,3.14,'2021-07-02'),
(58,58,1,24.00,'2021-07-02'),
(59,59,4,5.40,'2021-07-02'),
(60,60,2,17.46,'2021-07-02'),
(61,61,21,5.12,'2021-07-02'),
(62,62,1,52.27,'2021-07-02'),
(63,63,100,1.14,'2021-07-02'),
(64,64,12,7.52,'2021-07-02'),
(65,65,100,1.09,'2021-07-02'),
(66,66,12,7.16,'2021-07-02'),
(67,67,100,0.40,'2021-07-02'),
(68,68,50,1.10,'2021-07-21'),
(69,69,21,1.70,'2021-07-02'),
(70,70,21,2.52,'2021-07-02'),
(71,71,21,2.58,'2021-07-02'),
(72,72,21,2.46,'2021-07-02'),
(73,73,21,2.20,'2021-07-02'),
(74,74,3,3.40,'2021-07-02'),
(75,75,5,3.56,'2021-07-02'),
(76,76,3,3.56,'2021-07-02'),
(77,77,5,3.56,'2021-07-02'),
(78,78,3,3.56,'2021-07-02'),
(79,79,20,2.00,'2021-07-02'),
(80,80,20,2.90,'2021-07-02'),
(81,81,20,2.00,'2021-07-02');

INSERT INTO `estoque` VALUES 
(1,1,12,1.47),
(2,2,3,24.93),
(3,3,5,33.66),
(4,4,30,1.37),
(5,5,12,12.23),
(6,6,12,17.24),
(7,7,9,3.17),
(8,8,12,2.23),
(9,9,3,12.40),
(10,10,10,16.30),
(11,11,4,7.17),
(12,12,6,16.71),
(13,13,5,27.57),
(14,14,2,56.21),
(15,15,30,1.94),
(16,16,20,8.14),
(17,17,5,24.93),
(18,18,3,5.00),
(19,19,2,6.67),
(20,20,5,3.84),
(21,21,50,1.35),
(22,22,2,7.87),
(23,23,2,8.22),
(24,24,2,8.00),
(25,25,2,8.00),
(26,26,5,36.07),
(27,27,5,17.28),
(28,28,5,27.28),
(29,29,21,33.19),
(30,30,10,9.35),
(31,31,21,2.00),
(32,32,20,2.90),
(33,33,21,1.60),
(34,34,12,4.53),
(35,35,21,2.25),
(36,36,20,3.00),
(37,37,20,3.35),
(38,38,21,2.00),
(39,39,10,5.00),
(40,40,20,2.62),
(41,41,20,2.81),
(42,42,20,2.48),
(43,20,20,2.50),
(44,44,20,2.50),
(45,45,100,1.29),
(46,46,21,1.90),
(47,47,12,1.20),
(48,48,12,1.90),
(49,49,20,2.05),
(50,50,20,3.00),
(51,51,20,3.00),
(52,52,15,2.61),
(53,53,50,0.72),
(54,54,30,1.21),
(55,55,6,2.38),
(56,56,3,7.00),
(57,57,21,3.14),
(58,58,1,24.00),
(59,59,4,5.40),
(60,60,2,17.46),
(61,61,21,5.12),
(62,62,1,52.27),
(63,63,100,1.14),
(64,64,12,7.52),
(65,65,100,1.09),
(66,66,12,7.16),
(67,67,100,0.40),
(68,68,50,1.10),
(69,69,21,1.70),
(70,70,21,2.52),
(71,71,21,2.58),
(72,72,21,2.46),
(73,73,21,2.20),
(74,74,3,3.40),
(75,75,5,3.56),
(76,76,3,3.56),
(77,77,5,3.56),
(78,78,3,3.56),
(79,79,20,2.00),
(80,80,20,2.90),
(81,81,20,2.00);

// TRIGGER

CREATE TABLE `estoques` (
`id` BIGINT(11) NOT NULL AUTO_INCREMENT,
`id_produto` INT(11) NULL DEFAULT NULL,
`qtde` INT(11) NULL DEFAULT NULL,
`valor_unitario` DECIMAL(9,2) NULL DEFAULT '0.00',
PRIMARY KEY (`id`));

PROCEDURE “SP_AtualizaEstoque”

Esse procedure recebe três parâmetros (id_prod, qtde_comprada, valor_unit) e 
tem a finalidade de inserir ou debitar produtos na tabela de “ESTOQUES” 
de acordo com o os parâmetros que são passados.

DELIMITER //
  CREATE PROCEDURE `SP_AtualizaEstoque`( `id_prod` int, `qtde_comprada` int, valor_unit decimal(9,2))
BEGIN
    declare contador int(11);

    SELECT count(*) into contador FROM estoques WHERE id_produto = id_prod;

    IF contador > 0 THEN
        UPDATE estoques SET qtde=qtde + qtde_comprada, valor_unitario= valor_unit
        WHERE id_produto = id_prod;
    ELSE
        INSERT INTO estoques (id_produto, qtde, valor_unitario) values (id_prod, qtde_comprada, valor_unit);
    END IF;
END //
DELIMITER ;


TRIGGER “TRG_EntradaProduto_AI”

Esse trigger será disparado após a inserção de um registro na tabela de 
“ENTRADA_PRODUTOS”:

DELIMITER //
CREATE TRIGGER `TRG_EntradaProduto_AI` AFTER INSERT ON `entrada_produtos`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (new.id_produto, new.qtde, new.valor_unitario);
END //
DELIMITER ;


TRIGGER “TRG_EntradaProduto_AU”

Esse trigger será disparado após a atualização de um registro na tabela 
de “ENTRADA_PRODUTOS ”.

DELIMITER //
CREATE TRIGGER `TRG_EntradaProduto_AU` AFTER UPDATE ON `entrada_produtos`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (new.id_produto, new.qtde - old.qtde, new.valor_unitario);
END //
DELIMITER ;


 Tirar Dúvida
Anotações
Favoritar
Concluído
58 Gostei

58

Artigos
Banco de Dados
Implementando controle de estoque no MySQL com triggers e procedures

Neste artigo será demonstrado como podemos controlar estoques internamente no MySQL usando triggers (gatilhos) e stored procedures.

Uma funcionalidade básica e obrigatória dos sistemas desenvolvidos para o comércio e empresas em geral é o controle do estoque dos produtos, desse modo o vendedor consegue consultar no sistema e verificar a disponibilidade de um determinado produto em tempo real. Com essas informações setores como compras e PCP conseguem planejar melhor as atividades de compra e produção.

Existem várias técnicas para se controlar os estoques, cada programador desenvolve um controle de estoque que atenda as necessidades do seu cliente. Aqui será demonstrada uma forma de implementar esse controle, tomando como exemplo os estoques de uma papelaria.

Vamos construir um pequeno banco de dados “PAPELARIA” usando o MySQL 5.5.24, nesse banco vamos criar quatro tabelas e alguns triggers e um procedure:

    PRODUTO
    ENTRADA_PRODUTO
    ESTOQUE
    SAIDA_PRODUTO

Abaixo segue uma breve descrição e Script para cada tabela:
TABELA “PRODUTO”

A tabela de “PRODUTO” vai conter o cadastro dos produtos que a papelaria vende, nesse exemplo foram criados somente os campos básicos para esse tipo de cadastro, segue abaixo o Script para criação dessa tabela.

CREATE TABLE `produto` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`status` CHAR(1) NOT NULL DEFAULT 'A',
`descricao` VARCHAR(50) NULL DEFAULT NULL,
`estoque_minimo` INT(11) NULL DEFAULT NULL,
`estoque_maximo` INT(11) NULL DEFAULT NULL,
PRIMARY KEY (`id`))

Listagem 1. Script de criação da tabela Produtos

Para adiantar um pouco foram cadastrados alguns produtos. Vale uma observação para o campo “STATUS”, que indica se o cadastro está ativo “A” ou inativo “I”, somente para fins didáticos.
Lista de produtos já cadastrados na tabela PRODUTO
Figura 1. Lista de produtos já cadastrados na tabela PRODUTO
TABELA “ENTRADA_PRODUTO”

Nessa tabela serão gravadas todas as compras de produtos efetuadas para papelaria e através de triggers vamos controlar as inserções na tabela de “ESTOQUE”, segue abaixo o Script para criação dessa tabela.

CREATE TABLE `entrada_produto` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`id_produto` INT(11) NULL DEFAULT NULL,
`qtde` INT(11) NULL DEFAULT NULL,
`valor_unitario` DECIMAL(9,2) NULL DEFAULT '0.00',
`data_entrada` DATE NULL DEFAULT NULL,
PRIMARY KEY (`id`))

Listagem 2. Script de criação da tabela ENTRADA_PRODUTO

Para esse artigo não estaremos usando Foreign Keys (Chaves Estrangeiras), notem que o campo “ID_PRODUTO” não está configurado como FK. Imaginem que todas as compras serão lançadas nessa tabela.
TABELA “ESTOQUE”

Essa tabela somente recebe os dados conforme as ações executadas nas tabelas de “ENTRADA_PRODUTO” e “SAIDA_PRODUTO”. O usuário não tem interação direta como INSERÇÕES, UPDATES E EXCLUSÕES, a tabela “ESTOQUE” é somente o resultado das ações de compra e venda de produtos. Segue abaixo o script para criação dessa tabela.

CREATE TABLE `estoque` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`id_produto` INT(11) NULL DEFAULT NULL,
`qtde` INT(11) NULL DEFAULT NULL,
`valor_unitario` DECIMAL(9,2) NULL DEFAULT '0.00',
PRIMARY KEY (`id`))

Listagem 3. Script de criação da tabela ESTOQUE
TABELA “SAIDA_PRODUTO”

Nessa tabela serão gravadas todas as saídas (Vendas) de produtos e através de triggers essas ações serão refletidas na tabela de “ESTOQUE”. Segue abaixo script para criação dessa tabela.

CREATE TABLE `saida_produto` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`id_produto` INT(11) NULL DEFAULT NULL,
`qtde` INT(11) NULL DEFAULT NULL,
`data_saida` DATE NULL DEFAULT NULL,
`valor_unitario` DECIMAL(9,2) NULL DEFAULT '0.00',
PRIMARY KEY (`id`))

Listagem 4. Script de criação da tabela SAIDA_PRODUTO

Agora vamos criar apenas um procedure que vai atualizar os estoques na tabela de “ESTOQUE”. Notem que nas quatro tabelas criadas existem dois campos em comum “ID_PRODUTO” e “QTDE”, são estes campos que serviram como parâmetros para inserção e baixa de estoque nos procedures.

Abaixo segue uma breve descrição e script para cada procedure.
PROCEDURE “SP_AtualizaEstoque”

Esse procedure recebe três parâmetros (id_prod, qtde_comprada, valor_unit) e tem a finalidade de inserir ou debitar produtos na tabela de “ESTOQUE” de acordo com o os parâmetros que são passados.

DELIMITER //
  CREATE PROCEDURE `SP_AtualizaEstoque`( `id_prod` int, `qtde_comprada` int, valor_unit decimal(9,2))
BEGIN
    declare contador int(11);

    SELECT count(*) into contador FROM estoque WHERE id_produto = id_prod;

    IF contador > 0 THEN
        UPDATE estoque SET qtde=qtde + qtde_comprada, valor_unitario= valor_unit
        WHERE id_produto = id_prod;
    ELSE
        INSERT INTO estoque (id_produto, qtde, valor_unitario) values (id_prod, qtde_comprada, valor_unit);
    END IF;
END //
DELIMITER ;

Listagem 5. Script de criação do procedure SP_AtualizaEstoque

Observem que foi declarada uma variável contador para receber o valor da instrução SELECT count(*). Caso exista um produto cadastrado no estoque com o mesmo id_prod passado como parâmetro, então será inserido na variável contador o número de linhas que atendem a essa condição. Posteriormente verifica-se o valor de contador, se for maior que 0 então executa-se um UPDATE na tabela “ESTOQUE”, senão é feito um “INSERT”. Essa verificação pode ser feita de diversas maneiras, o leitor fique à vontade para implementar da melhor maneira possível.

Vamos agora criar os triggers que serão ativadas sempre que ocorrerem eventos de INSERT, UPDATE e DELETE. Será criado uma trigger para cada evento das tabelas “ENTRADA_PRODUTO” e “SAIDA_PRODUTO” ao todo serão 6 triggers. Infelizmente o MySQL ainda não suporta múltiplos eventos em um mesmo trigger, então teremos um pouquinho de trabalho nessa fase.

    TRG_EntradaProduto_AI;
    TRG_EntradaProduto_AU;
    TRG_EntradaProduto_AD;
    TRG_SaidaProduto_AI;
    TRG_SaidaProduto_AU;
    TRG_SaidaProduto_AD.

Observação: o padrão usado para nomenclatura dos triggers varia conforme o programador, aqui iniciaremos com “TRG”, abreviação de Trigger + nome da + identificação do evento em que será disparado a trigger:

    AI : After Insert (Após Inserção);
    AU: After Update (Após Atualização);
    AD: After Delete (Após Exclusão).

Basicamente cada trigger vai conter apenas uma linha de instrução, que será a chamada de um procedure. Vale lembrar que para criar triggers é importante saber trabalhar com os identificadores “NEW” e “OLD”. Sendo NEW para o novo valor inserido ou atualizado e OLD para o antigo valor, que pode ser antes da atualização e após a exclusão.

Abaixo segue uma breve descrição e Script para cada trigger.
TRIGGER “TRG_EntradaProduto_AI”

Esse trigger será disparado após a inserção de um registro na tabela de “ENTRADA_PRODUTO”:
Listagem 6: Script de criação do trigger TRG_EntradaProduto_AI

DELIMITER //
CREATE TRIGGER `TRG_EntradaProduto_AI` AFTER INSERT ON `entrada_produto`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (new.id_produto, new.qtde, new.valor_unitario);
END //
DELIMITER ;

Listagem 1. NOME
TRIGGER “TRG_EntradaProduto_AU”

Esse trigger será disparado após a atualização de um registro na tabela de “ENTRADA_PRODUTO ”.

DELIMITER //
CREATE TRIGGER `TRG_EntradaProduto_AU` AFTER UPDATE ON `entrada_produto`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (new.id_produto, new.qtde - old.qtde, new.valor_unitario);
END //
DELIMITER ;

Listagem 7. Script de criação do trigger TRG_EntradaProduto_AU
TRIGGER “TRG_EntradaProduto_AD”


 Tirar Dúvida
Anotações
Favoritar
Concluído
58 Gostei

58

Artigos
Banco de Dados
Implementando controle de estoque no MySQL com triggers e procedures

Neste artigo será demonstrado como podemos controlar estoques internamente no MySQL usando triggers (gatilhos) e stored procedures.

Uma funcionalidade básica e obrigatória dos sistemas desenvolvidos para o comércio e empresas em geral é o controle do estoque dos produtos, desse modo o vendedor consegue consultar no sistema e verificar a disponibilidade de um determinado produto em tempo real. Com essas informações setores como compras e PCP conseguem planejar melhor as atividades de compra e produção.

Existem várias técnicas para se controlar os estoques, cada programador desenvolve um controle de estoque que atenda as necessidades do seu cliente. Aqui será demonstrada uma forma de implementar esse controle, tomando como exemplo os estoques de uma papelaria.

Vamos construir um pequeno banco de dados “PAPELARIA” usando o MySQL 5.5.24, nesse banco vamos criar quatro tabelas e alguns triggers e um procedure:

    PRODUTO
    ENTRADA_PRODUTO
    ESTOQUE
    SAIDA_PRODUTO

Abaixo segue uma breve descrição e Script para cada tabela:
TABELA “PRODUTO”

A tabela de “PRODUTO” vai conter o cadastro dos produtos que a papelaria vende, nesse exemplo foram criados somente os campos básicos para esse tipo de cadastro, segue abaixo o Script para criação dessa tabela.

CREATE TABLE `produto` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`status` CHAR(1) NOT NULL DEFAULT 'A',
`descricao` VARCHAR(50) NULL DEFAULT NULL,
`estoque_minimo` INT(11) NULL DEFAULT NULL,
`estoque_maximo` INT(11) NULL DEFAULT NULL,
PRIMARY KEY (`id`))

Listagem 1. Script de criação da tabela Produtos

Para adiantar um pouco foram cadastrados alguns produtos. Vale uma observação para o campo “STATUS”, que indica se o cadastro está ativo “A” ou inativo “I”, somente para fins didáticos.
Lista de produtos já cadastrados na tabela PRODUTO
Figura 1. Lista de produtos já cadastrados na tabela PRODUTO
TABELA “ENTRADA_PRODUTO”

Nessa tabela serão gravadas todas as compras de produtos efetuadas para papelaria e através de triggers vamos controlar as inserções na tabela de “ESTOQUE”, segue abaixo o Script para criação dessa tabela.

CREATE TABLE `entrada_produto` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`id_produto` INT(11) NULL DEFAULT NULL,
`qtde` INT(11) NULL DEFAULT NULL,
`valor_unitario` DECIMAL(9,2) NULL DEFAULT '0.00',
`data_entrada` DATE NULL DEFAULT NULL,
PRIMARY KEY (`id`))

Listagem 2. Script de criação da tabela ENTRADA_PRODUTO

Para esse artigo não estaremos usando Foreign Keys (Chaves Estrangeiras), notem que o campo “ID_PRODUTO” não está configurado como FK. Imaginem que todas as compras serão lançadas nessa tabela.
TABELA “ESTOQUE”

Essa tabela somente recebe os dados conforme as ações executadas nas tabelas de “ENTRADA_PRODUTO” e “SAIDA_PRODUTO”. O usuário não tem interação direta como INSERÇÕES, UPDATES E EXCLUSÕES, a tabela “ESTOQUE” é somente o resultado das ações de compra e venda de produtos. Segue abaixo o script para criação dessa tabela.

CREATE TABLE `estoque` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`id_produto` INT(11) NULL DEFAULT NULL,
`qtde` INT(11) NULL DEFAULT NULL,
`valor_unitario` DECIMAL(9,2) NULL DEFAULT '0.00',
PRIMARY KEY (`id`))

Listagem 3. Script de criação da tabela ESTOQUE
TABELA “SAIDA_PRODUTO”

Nessa tabela serão gravadas todas as saídas (Vendas) de produtos e através de triggers essas ações serão refletidas na tabela de “ESTOQUE”. Segue abaixo script para criação dessa tabela.

CREATE TABLE `saida_produtos` (
`id` BIGINT(11) NOT NULL AUTO_INCREMENT,
`id_produto` INT(11) NULL DEFAULT NULL,
`qtde` INT(11) NULL DEFAULT NULL,
`data_saida` DATE NULL DEFAULT NULL,
`valor_unitario` DECIMAL(9,2) NULL DEFAULT '0.00',
PRIMARY KEY (`id`))

Listagem 4. Script de criação da tabela SAIDA_PRODUTO

Agora vamos criar apenas um procedure que vai atualizar os estoques na 
tabela de “ESTOQUES”. Notem que nas quatro tabelas criadas existem dois 
campos em comum “ID_PRODUTO” e “QTDE”, são estes campos que serviram como 
parâmetros para inserção e baixa de estoque nos procedures.

=============================================================
Abaixo segue uma breve descrição e script para cada procedure.
PROCEDURE “SP_AtualizaEstoque”

Esse procedure recebe três parâmetros (id_prod, qtde_comprada, valor_unit) e tem a finalidade de inserir ou debitar produtos na tabela de “ESTOQUE” de acordo com o os parâmetros que são passados.

DELIMITER //
  CREATE PROCEDURE `SP_AtualizaEstoque`( `id_prod` int, `qtde_comprada` int, valor_unit decimal(9,2))
BEGIN
    declare contador int(11);

    SELECT count(*) into contador FROM estoque WHERE id_produto = id_prod;

    IF contador > 0 THEN
        UPDATE estoque SET qtde=qtde + qtde_comprada, valor_unitario= valor_unit
        WHERE id_produto = id_prod;
    ELSE
        INSERT INTO estoque (id_produto, qtde, valor_unitario) values (id_prod, qtde_comprada, valor_unit);
    END IF;
END //
DELIMITER ;

===============================================================================
Listagem 5. Script de criação do procedure SP_AtualizaEstoque

Observem que foi declarada uma variável contador para receber o valor da instrução SELECT count(*). Caso exista um produto cadastrado no estoque com o mesmo id_prod passado como parâmetro, então será inserido na variável contador o número de linhas que atendem a essa condição. Posteriormente verifica-se o valor de contador, se for maior que 0 então executa-se um UPDATE na tabela “ESTOQUE”, senão é feito um “INSERT”. Essa verificação pode ser feita de diversas maneiras, o leitor fique à vontade para implementar da melhor maneira possível.

Vamos agora criar os triggers que serão ativadas sempre que ocorrerem eventos de INSERT, UPDATE e DELETE. Será criado uma trigger para cada evento das tabelas “ENTRADA_PRODUTO” e “SAIDA_PRODUTO” ao todo serão 6 triggers. Infelizmente o MySQL ainda não suporta múltiplos eventos em um mesmo trigger, então teremos um pouquinho de trabalho nessa fase.

    TRG_EntradaProduto_AI;
    TRG_EntradaProduto_AU;
    TRG_EntradaProduto_AD;
    TRG_SaidaProduto_AI;
    TRG_SaidaProduto_AU;
    TRG_SaidaProduto_AD.

Observação: o padrão usado para nomenclatura dos triggers varia conforme o programador, aqui iniciaremos com “TRG”, abreviação de Trigger + nome da + identificação do evento em que será disparado a trigger:

    AI : After Insert (Após Inserção);
    AU: After Update (Após Atualização);
    AD: After Delete (Após Exclusão).

Basicamente cada trigger vai conter apenas uma linha de instrução, que será a chamada de um procedure. Vale lembrar que para criar triggers é importante saber trabalhar com os identificadores “NEW” e “OLD”. Sendo NEW para o novo valor inserido ou atualizado e OLD para o antigo valor, que pode ser antes da atualização e após a exclusão.
================================================================
Abaixo segue uma breve descrição e Script para cada trigger.
TRIGGER “TRG_EntradaProduto_AI”

Esse trigger será disparado após a inserção de um registro na tabela de “ENTRADA_PRODUTO”:
Listagem 6: Script de criação do trigger TRG_EntradaProduto_AI

DELIMITER //
CREATE TRIGGER `TRG_EntradaProduto_AI` AFTER INSERT ON `entrada_produtos`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (new.id_produto, new.qtde, new.valor_unitario);
END //
DELIMITER ;

==============================================================================

Listagem 1. NOME
TRIGGER “TRG_EntradaProduto_AU”

Esse trigger será disparado após a atualização de um registro na tabela de “ENTRADA_PRODUTO ”.

DELIMITER //
CREATE TRIGGER `TRG_EntradaProduto_AU` AFTER UPDATE ON `entrada_produtos`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (new.id_produto, new.qtde - old.qtde, new.valor_unitario);
END //
DELIMITER ;

==============================================================================

TRIGGER “TRG_EntradaProduto_AD”

Esse trigger será disparado após a exclusão de um registro na tabela de 
“ENTRADA_PRODUTOS”.

DELIMITER //
CREATE TRIGGER `TRG_EntradaProduto_AD` AFTER DELETE ON `entrada_produtos`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (old.id_produto, old.qtde * -1, old.valor_unitario);
END //
DELIMITER ;

==============================================================================

TRIGGER “TRG_SaidaProduto_AI”

Esse trigger será disparado após a inserção 
de um registro na tabela de “SAIDA_PRODUTOS”.

DELIMITER //
CREATE TRIGGER `TRG_SaidaProduto_AI` AFTER INSERT ON `saida_produtos`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (new.id_produto, new.qtde * -1, new.valor_unitario);
END //
DELIMITER ;

==============================================================================
TRIGGER “TRG_ SaidaProduto _AU”
Esse trigger será disparado após a atualização de um registro na tabela 
“SAIDA_PRODUTOS”.

DELIMITER //
CREATE TRIGGER `TRG_SaidaProduto_AU` AFTER UPDATE ON `saida_produtos`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (new.id_produto, old.qtde - new.qtde, new.valor_unitario);
END //
DELIMITER ;

==============================================================================
TRIGGER “TRG_ SaidaProduto _AD”

Esse trigger será disparado após a exclusão de um registro 
na tabela de “SAIDA_PRODUTO”.

DELIMITER //
CREATE TRIGGER `TRG_SaidaProduto_AD` AFTER DELETE ON `saida_produtos`
FOR EACH ROW
BEGIN
      CALL SP_AtualizaEstoque (old.id_produto, old.qtde, old.valor_unitario);
END //
DELIMITER ;

